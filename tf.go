package cfft

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/cloudfront"
	"github.com/aws/aws-sdk-go-v2/service/cloudfront/types"
)

type TFCmd struct {
	External     bool   `cmd:"" help:"output JSON for external data source"`
	Publish      *bool  `cmd:"" help:"set publish flag" default:"false"`
	ResourceName string `cmd:"" help:"resource name"`
	Live         bool   `cmd:"" help:"compare with live function code" default:"true"`
}

type TFJSON struct {
	Comment  string           `json:"//"`
	Variable map[string]TFVar `json:"variable,omitempty"`
	Resource TFCFF            `json:"resource"`
}

type TFVar struct {
	Type        string `json:"type"`
	Default     string `json:"default"`
	Description string `json:"description"`
}

const TFJSONComment = `This file is generated by cfft. DO NOT EDIT.`

type TFCFF struct {
	AWSCloudFrontFunction map[string]TFOutout `json:"aws_cloudfront_function"`
}

type TFOutout struct {
	Name    string                `json:"name"`
	Code    string                `json:"code"`
	Runtime types.FunctionRuntime `json:"runtime"`
	Comment string                `json:"comment"`
	Publish *bool                 `json:"publish,omitempty"`
}

func (app *CFFT) getLiveFunctionCode(ctx context.Context) ([]byte, error) {
	res, err := app.cloudfront.GetFunction(ctx, &cloudfront.GetFunctionInput{
		Name:  aws.String(app.config.Name),
		Stage: types.FunctionStageLive,
	})
	if err != nil {
		var notFound *types.NoSuchFunctionExists
		if errors.As(err, &notFound) {
			// Live function does not exist, This is not an error
			slog.Info(f("live function %s not found", app.config.Name))
			return nil, nil
		}
		return nil, fmt.Errorf("failed to get function code, %w", err)
	}
	slog.Info(f("live function %s found", app.config.Name))

	return RemoveHeaderComment(res.FunctionCode), nil
}

func (app *CFFT) RunTF(ctx context.Context, opt *TFCmd) error {
	var liveCode []byte
	var err error
	if opt.Live { // compare with live function code
		liveCode, err = app.getLiveFunctionCode(ctx)
		if err != nil {
			return err
		}
	}

	code, err := app.config.FunctionCode(ctx, liveCode)
	if err != nil {
		return fmt.Errorf("failed to read function code, %w", err)
	}
	localCode := string(code)
	var rname string
	if opt.ResourceName != "" {
		rname = opt.ResourceName
	} else {
		rname = app.config.Name
	}
	out := TFOutout{
		Name:    rname,
		Runtime: app.config.Runtime,
		Comment: app.config.Comment,
	}
	enc := json.NewEncoder(app.stdout)
	enc.SetIndent("", "  ")

	if opt.External {
		// for external data source
		out.Code = localCode
		out.Publish = nil // external data source does not allows boolean value
		return enc.Encode(out)
	} else {
		// output tf.json
		out.Publish = opt.Publish // Publish flag is only for tf.json
		resource := TFJSON{
			Comment: TFJSONComment,
		}
		if strings.Contains(localCode, "${") {
			// local code contains interpolation. use variable to avoid tf template evaluation error
			varName := fmt.Sprintf("cfft_code_of_%s", rname)
			resource.Variable = map[string]TFVar{
				varName: {
					Type:        "string",
					Default:     localCode,
					Description: "CloudFront Function code of " + app.config.Name,
				},
			}
			out.Code = fmt.Sprintf("${var.%s}", varName)
		} else {
			// local code does not contain interpolation. use inline code
			out.Code = localCode
		}
		resource.Resource = TFCFF{
			AWSCloudFrontFunction: map[string]TFOutout{
				rname: out,
			},
		}
		return enc.Encode(&resource)
	}
}
